// SPDX-FileCopyrightText: 2023 SAP SE
//
// SPDX-License-Identifier: Apache-2.0
//
// This file is part of FEDEM - https://openfedem.org
////////////////////////////////////////////////////////////////////////////////

/*!
  \file SignalHandler.C

  \brief Handling of various OS signals casing the program to abort.
*/

#include <iostream>

#include "SignalHandler.H"
#include "FFaLib/FFaCmdLineArg/FFaCmdLineArg.H"
#include <signal.h>
#ifdef __GNUC__
#include <execinfo.h>
#include <stdio.h>
#endif


std::string SignalHandler::myProgName;
VoidFuncPtr SignalHandler::emergencyExit     = [](){};
VoidFuncPtr SignalHandler::emergencySaveExit = [](){};
VoidFuncPtr SignalHandler::killAllChilds     = [](){};


void SignalHandler::init(const char* program,
			 VoidFuncPtr f1, VoidFuncPtr f2, VoidFuncPtr f3)
{
  bool noSigHndl = false;
  FFaCmdLineArg::instance()->getValue ("noSignalHandling",noSigHndl);
  if (noSigHndl) return;

  myProgName = program;
  if (f1) emergencyExit = f1;

  if (f2)
    emergencySaveExit = f2;
  else if (f1)
    emergencySaveExit = f1;

  if (f3) killAllChilds = f3;

#ifdef FT_DEBUG
#ifdef __GNUC__
  signal(SIGSEGV,&processSignal); // Segmentation violation.
#endif
#else // We do **not** handle other signals when compiled in debug mode
  signal(SIGINT ,&processSignal); // User presses ctrl-C.
  signal(SIGILL ,&processSignal); // Illegal hardware instruction.
  signal(SIGABRT,&processSignal); // Generated by abort function.
  signal(SIGFPE ,&processSignal); // Division by 0, overflow, etc ...
  signal(SIGSEGV,&processSignal); // Segmentation violation.
  signal(SIGTERM,&processSignal); // Software termination.
#if !defined(win32) && !defined(win64)
  // Signals not supportend on Windows platforms:
  signal(SIGQUIT,&processSignal); // User presses ctrl-\.
  signal(SIGBUS ,&processSignal); // Bus error.
  signal(SIGSYS, &processSignal); // Bad system call.
  signal(SIGPIPE,&processSignal); // Broken pipe.
  signal(SIGXCPU,&processSignal); // CPU time limit exceeded.
  signal(SIGXFSZ,&processSignal); // File size limit exceeded.
#endif
#endif
}


void SignalHandler::reset()
{
#ifdef FT_DEBUG
#ifdef __GNUC__
  signal(SIGSEGV,SIG_DFL);
#endif
#else
  signal(SIGINT ,SIG_DFL);
  signal(SIGILL ,SIG_DFL);
  signal(SIGABRT,SIG_DFL);
  signal(SIGFPE ,SIG_DFL);
  signal(SIGSEGV,SIG_DFL);
  signal(SIGTERM,SIG_DFL);
#if !defined(win32) && !defined(win64)
  signal(SIGQUIT,SIG_DFL);
  signal(SIGBUS ,SIG_DFL);
  signal(SIGSYS, SIG_DFL);
  signal(SIGPIPE,SIG_DFL);
  signal(SIGXCPU,SIG_DFL);
  signal(SIGXFSZ,SIG_DFL);
#endif
#endif
}


void SignalHandler::processSignal(int sig)
{
  // Lambda function producing a symbol back trace when crashing.
  VoidFuncPtr backTrace = []()
  {
#ifdef __GNUC__
    void* array[10];
    size_t size = backtrace(array,10);
    backtrace_symbols_fd(array,size,STDERR_FILENO);
#endif
  };

  enum { NONE, SAVE_AND_EXIT, EXIT, CLEAN_UP_CHILDREN, BACK_TRACE } action;

  std::string strsig;
  switch (sig)
  {
    case SIGINT: // User presses ctrl-C.
      strsig = "SIGINT Interrupt";
      action = EXIT;
      break;

    case SIGILL: // Illegal hardware instruction.
      strsig = "SIGILL Illegal instruction";
      action = SAVE_AND_EXIT;
      break;

    case SIGABRT: // Generated by abort function.
      strsig = "SIGABRT Abort";
      action = SAVE_AND_EXIT;
      break;

    case SIGFPE: // Division by 0, overflow, etc...
      strsig = "SIGFPE Arithmetic exception";
      action = SAVE_AND_EXIT;
      break;

    case SIGSEGV: // Segmentation violation.
      strsig = "SIGSEGV Segmentation violation";
#ifdef FT_DEBUG
      action = BACK_TRACE;
#else
      action = SAVE_AND_EXIT;
#endif
      break;

    case SIGTERM: // Software termination sent by kill and system shutdown.
      strsig = "SIGTERM Software termination";
      action = EXIT;
      break;

#if !defined(win32) && !defined(win64)
    case SIGQUIT: // User presses ctrl-\.
      strsig = "SIGQUIT Quit";
      action = EXIT;
      break;

    case SIGBUS: // Bus error.
      strsig = "SIGBUS Bus error";
      action = SAVE_AND_EXIT;
      break;

    case SIGSYS: // Bad system call.
      strsig = "SIGSYS Bad system call";
      action = EXIT;
      break;

    case SIGPIPE: // Broken pipe.
      strsig = "SIGPIPE Broken pipe";
      action = CLEAN_UP_CHILDREN;
      break;

    case SIGXCPU: // CPU time limit exceeded.
      strsig = "SIGXCPU CPU time limit exceeded";
      action = SAVE_AND_EXIT;
      break;

    case SIGXFSZ: // File size limit exceeded.
      strsig = "SIGXFSZ File size limit exceeded";
      action = SAVE_AND_EXIT;
      break;
#endif

    default:
      action = NONE;
  }

  if (action != NONE)
    std::cout <<"\n *** "<< myProgName <<" recieved signal "<< strsig <<".\n";

  switch (action) {
  case SAVE_AND_EXIT:
    std::cout <<" *** "<< myProgName <<" trying emergency save and exit..."
              << std::endl;
    emergencySaveExit();
    exit(-1);

  case EXIT:
    std::cout <<" *** "<< myProgName <<" exiting..."<< std::endl;
    emergencyExit();
    exit(-1);

  case CLEAN_UP_CHILDREN:
    std::cout <<" *** "<< myProgName <<" cleaning up child processes (if any)."
              << std::endl;
    killAllChilds();
    break;

  case BACK_TRACE:
    backTrace();
    exit(-1);

  default:
    break;
  }

  signal(sig,&processSignal); // Resetting signal handler
}
